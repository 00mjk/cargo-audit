//! Presenter for `rustsec::Report` information.

use crate::{
    config::{DenyWarningOption, OutputConfig, OutputFormat},
    prelude::*,
};
use abscissa_core::terminal::{
    self,
    Color::{self, Red, Yellow},
};
use rustsec::{
    cargo_lock::{
        dependency::{self, graph::EdgeDirection, Dependency},
        Lockfile, Package,
    },
    warning, Vulnerability, Warning,
};
use std::{
    collections::BTreeSet as Set,
    io::{self, Write},
    path::Path,
    process::exit,
};

/// Vulnerability information presenter
#[derive(Clone, Debug)]
pub struct Presenter {
    /// Keep track packages we've displayed once so we don't show the same dep tree
    // TODO(tarcieri): group advisories about the same package?
    displayed_packages: Set<Dependency>,

    /// Keep track of the warning kinds that correspond to deny-warnings options
    deny_warning_kinds: Set<warning::Kind>,

    /// Output configuration
    config: OutputConfig,
}

impl Presenter {
    /// Create a new vulnerability information presenter
    pub fn new(config: &OutputConfig) -> Self {
        Self {
            displayed_packages: Set::new(),
            deny_warning_kinds: config
                .deny_warnings
                .iter()
                .filter_map(|k| k.get_warning_kind())
                .collect(),
            config: config.clone(),
        }
    }

    /// Information to display before a report is generated
    pub fn before_report(&mut self, lockfile_path: &Path, lockfile: &Lockfile) {
        if !self.config.is_quiet() {
            status_ok!(
                "Scanning",
                "{} for vulnerabilities ({} crate dependencies)",
                lockfile_path.display(),
                lockfile.packages.len(),
            );
        }
    }

    fn warning_word(&self, count: u64) -> &str {
        if count != 1 {
            "warnings"
        } else {
            "warning"
        }
    }

    /// Print the vulnerability report generated by an audit
    pub fn print_report(
        &mut self,
        report: &rustsec::Report,
        self_advisories: &[rustsec::Advisory],
        lockfile: &Lockfile,
    ) {
        if self.config.format == OutputFormat::Json {
            serde_json::to_writer(io::stdout(), &report).unwrap();
            io::stdout().flush().unwrap();
            return;
        }

        if report.vulnerabilities.found {
            status_err!("Vulnerable crates found!");
        } else {
            status_ok!("Success", "No vulnerable packages found");
        }

        let tree = lockfile
            .dependency_tree()
            .expect("invalid Cargo.lock dependency tree");

        for vulnerability in &report.vulnerabilities.list {
            self.print_vulnerability(vulnerability, &tree);
        }

        // sort warning::Kinds alphabetically
        let mut sorted_keys: Vec<&warning::Kind> = report
            .warnings
            .warnings
            .keys()
            .collect::<Vec<&warning::Kind>>();
        sorted_keys.sort();

        let mut num_denied: u64 = 0;
        let mut num_not_denied: u64 = 0;

        for kind in &sorted_keys {
            if self.deny_warning_kinds.contains(kind) {
                num_denied += report.warnings.warnings.get(kind).unwrap().len() as u64;
            } else {
                num_not_denied += report.warnings.warnings.get(kind).unwrap().len() as u64;
            }
        }

        status_err!("{} {} found", num_denied, self.warning_word(num_denied));

        status_warn!(
            "{} {} found",
            num_not_denied,
            self.warning_word(num_not_denied)
        );

        for kind in &sorted_keys {
            for warning in report.warnings.warnings.get(kind).unwrap() {
                self.print_warning(warning, &tree)
            }
        }

        if !self_advisories.is_empty() {
            println!();

            let msg = "this copy of cargo-audit has known advisories!";

            if self
                .config
                .deny_warnings
                .contains(&DenyWarningOption::Other)
            {
                status_err!(msg);
            } else {
                status_warn!(msg);
            }

            for advisory in self_advisories {
                self.print_advisory_warning(
                    &advisory.metadata,
                    self.config
                        .deny_warnings
                        .contains(&DenyWarningOption::Other),
                );
            }
        }

        if report.vulnerabilities.found {
            println!();

            if report.vulnerabilities.count == 1 {
                status_err!("1 vulnerability found!");
            } else {
                status_err!("{} vulnerabilities found!", report.vulnerabilities.count);
            }
        }

        if num_denied > 0 || num_not_denied > 0 {
            if !report.vulnerabilities.found {
                println!();
            }

            if num_denied > 0 {
                status_err!(
                    "{} denied {} found and `--deny-warnings` enabled!",
                    num_denied,
                    self.warning_word(num_denied)
                );

                // TODO(tarcieri): better unify this with vulnerabilities handling
                exit(1);
            } else {
                status_warn!(
                    "{} {} found!",
                    num_not_denied + num_denied,
                    self.warning_word(num_not_denied + num_denied)
                );
            }
        }

        let upgrade_msg = "upgrade cargo-audit to the latest version: \
                           cargo install --force cargo-audit";

        if !self_advisories.is_empty() {
            if self
                .config
                .deny_warnings
                .contains(&DenyWarningOption::Other)
            {
                status_err!(upgrade_msg);
                exit(1);
            } else {
                status_warn!(upgrade_msg);
            }
        }
    }

    /// Print information about the given vulnerability
    fn print_vulnerability(&mut self, vulnerability: &Vulnerability, tree: &dependency::Tree) {
        let advisory = &vulnerability.advisory;

        println!();
        self.print_attr(Red, "ID:      ", &advisory.id);
        self.print_attr(Red, "Crate:   ", &vulnerability.package.name);
        self.print_attr(Red, "Version: ", &vulnerability.package.version.to_string());
        self.print_attr(Red, "Date:    ", &advisory.date);

        if let Some(url) = advisory.id.url() {
            self.print_attr(Red, "URL:     ", &url);
        } else if let Some(url) = &advisory.url {
            self.print_attr(Red, "URL:     ", url);
        }

        self.print_attr(Red, "Title:   ", &advisory.title);
        if vulnerability.versions.patched.is_empty() {
            self.print_attr(
                Red,
                "Solution:",
                String::from(" No safe upgrade is available!"),
            );
        } else {
            self.print_attr(
                Red,
                "Solution:",
                String::from(" upgrade to ")
                    + &vulnerability
                        .versions
                        .patched
                        .iter()
                        .map(ToString::to_string)
                        .collect::<Vec<_>>()
                        .as_slice()
                        .join(" OR "),
            );
        }

        self.print_tree(Red, &vulnerability.package, tree);
    }

    /// Print information about a given warning
    fn print_warning(&mut self, warning: &Warning, tree: &dependency::Tree) {
        match &warning.kind {
            warning::Kind::Informational | warning::Kind::Unmaintained => {
                if let Some(advisory) = &warning.advisory {
                    self.print_advisory_warning(
                        advisory,
                        self.deny_warning_kinds.contains(&warning.kind),
                    )
                } else {
                    warn!("warning missing advisory: {:?}", warning);
                }
            }
            warning::Kind::Yanked => self.print_yanked_warning(&warning.package),
        }

        self.print_tree(
            self.warning_color(self.deny_warning_kinds.contains(&warning.kind)),
            &warning.package,
            tree,
        );
    }

    /// Get the color to use when displaying warnings
    fn warning_color(&self, deny_warning: bool) -> Color {
        if deny_warning {
            Red
        } else {
            Yellow
        }
    }

    /// Print a warning about a particular advisory
    fn print_advisory_warning(&self, metadata: &rustsec::advisory::Metadata, deny_warning: bool) {
        let color = self.warning_color(deny_warning);

        println!();
        self.print_attr(color, "Crate: ", &metadata.package);
        self.print_attr(color, "Title: ", &metadata.title);
        self.print_attr(color, "Date:  ", &metadata.date);

        if let Some(url) = metadata.id.url() {
            self.print_attr(color, "URL:   ", &url);
        } else if let Some(url) = &metadata.url {
            self.print_attr(color, "URL:   ", url);
        }
    }

    /// Print a warning about a yanked crate
    fn print_yanked_warning(&self, package: &Package) {
        let color = self.warning_color(self.deny_warning_kinds.contains(&warning::Kind::Yanked));

        println!();
        self.print_attr(color, "Crate:   ", &package.name);
        self.print_attr(color, "Version: ", package.version.to_string());
        self.print_attr(color, "Warning: ", "package has been yanked!");
    }

    /// Display an attribute of a particular vulnerability
    fn print_attr(&self, color: Color, attr: &str, content: impl AsRef<str>) {
        terminal::status::Status::new()
            .bold()
            .color(color)
            .status(attr)
            .print_stdout(content.as_ref())
            .unwrap();
    }

    /// Print the inverse dependency tree to standard output
    fn print_tree(&mut self, color: Color, package: &Package, tree: &dependency::Tree) {
        // Only show the tree once per package
        if !self.displayed_packages.insert(Dependency::from(package)) {
            return;
        }

        if !self.config.show_tree.unwrap_or(true) {
            return;
        }

        terminal::status::Status::new()
            .bold()
            .color(color)
            .status("Dependency tree:")
            .print_stdout("")
            .unwrap();

        let package_node = tree.nodes()[&Dependency::from(package)];
        tree.render(&mut io::stdout(), package_node, EdgeDirection::Incoming)
            .unwrap();
    }
}
